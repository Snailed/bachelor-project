\subsubsection{Design}
% Fortæl om bit masken, og hvordan den udregnes
% Fortæl om beregning af $l$
% Fortæl om vector-klassen i Rust, om beregninger på vektorer
One of the main design challenges of the implementation is to support multiple word sizes simultaneously to give an accurate estimate on how the execution time scales with the word size. This has the consequence of making it harder to hard-code values like $m_{i, j}$ and $l(i)$, since a theoretical implementation with a very large word size would have to compute these values at runtime.\\
This implementation uses hard-coded values however, since any real-life implementation with a reasonable word size would do so as well.\\
Another challenge is code optimization. Rust has an \texttt{\#[inline(always)]} macro that forces function inlining, which reduces the time needed to handle the stack.
A nice feature about the algorithm is that it does not use multiplication, which usually is a very slow operation. It does however operate on very large lists of numbers, which need to be handled efficiently. For this, the heap-allocated \texttt{Vec} data structure was used, as it functions as a dynamic array and contains many features to help with optimizations. For instance, the \texttt{Vec::with\_capacity(n)} constructor specifies an initial capacity of the dynamic array such that unnecessary allocations are avoided, and the \texttt{Vec::truncate()} allows constant time shortening of arrays \cite{rust-lang}.\\

